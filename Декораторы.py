# Декораторы - это самая сложная тема для начинающих програмистов.
# Декоратор - это некая функция, которая позволяет обернуть другую функцию для расширения ее функциональности,
# без изменения ее кода. Т.е. образно, декоратор - это некая обертка функции Пайтон, которая изменяет работу той
# функции, к которой она применяется.
#  Давайтре разбираться. Мы помним, что в Пайтон все является объектами, следовательно функция тоже является
#  объектом. И можем проводить с ними различные манипуляции, как и с другими объектами.

# Первый способ применения декораторар  (но этот способ не очень удобный. Гораздо удобнее - второй способ, см.ниже):
def my_decor(func):
    def wraper():
        print('Start')
        func()
        print('Emd')
    return wraper # тут мы без скообочек указываем нашу функцию wraper, т.к. мы ее не вызываем, а передаем
    # как значение.

# Теперь, вышенаписанный декратор нужно применить к какой-то простой функции. Давайте ее напишем:
def my_func(): # ничего она в себя не будет принимать (пожтому - пустые скобки)
    print('Тут основная фукнция')

# Теперь нужно обернуть нашу функцию и применить к ней декоратор. Есть несколько способов применения декораторов к
# какой-то существующей функции.
# Начнем с самого обычного способа. Создадим переменную my и присвоим ей значение выполнения функции декоратора:
my = my_decor(my_func) # снова без круглых скобочек после my_func.
my() # все что нам нужно, это вызвать данный объект (переменную) my.
# Start
# Тут основная фукнция
# Emd

# Что у нас происзошло: 1) сначала вызвалось сообщение Start 2) затем сработала наша основная функция, которую мы
# "обернули" в декоратор (вывело "Тут основная фукнция") 3) и в конце - сообщение "Stop".

# Зачем все это нужно:
# 1. Все это нужно, чтоб не повторять какие-то блоки кода.
# 2. Чтоб расширить действия и возможности нашей функции не изменяя ее кода.
# Это можно понять на следующем web-примере: например, у каждого пользователя, модератора  и админимтсратора сайта,
# есть какие-то общие действия (каждый из них может зайти в свой личный кабинет, посмотреть свои посты,
# отредактировать свои посты). Но например у пользователя "Модератор" появлеяется еще одно действие - он может
# редактировать, удалять чужие посты. И это все можно сделать при помощи декоратора.
# Для разработчиков Пайтон, которые будут работать с фрейм-ворками Flask, Jango - там декораторы применяются очень
# часто, особенно для разграничения прав пользователей на ресурсе.


# Второй и наиболее частый способ применения декоратора (например во Flask, Jango - в основном используется он:
# перед тем, как мы объявляем и создаем нашу основную функцию, мы указываем значек @ ("собачка") и указать имя нашего
# декоратора:

@my_decor
def my_func(): # ничего она в себя не будет принимать (пожтому - пустые скобки)
    print('Тут основная фукнция')
# И все что нам нужно будет сделать, это просто вызвать нашу основную функцию:
my_func()
# Start
# Тут основная фукнция
# Emd

# Т.е. будет использоваться и чаще всего встречаться именно такая форма применеиния декоратора: 1) сначала через
# собачку пишется имя декоратора; 2) затем под декоратором пишется основная функция, которую оборачивают в декоратор.


# Итог:
# Испльзование декоратора позволяет нам упростить код, особенно если необходимо выполнить какие-то повторяющиеся
# действия над различными функциями программы. Гораздо реже декораторы используют для того, чтоб скрыть некоторые
# данный программы.

# Теперь усложним. Пример:
# Повторяем блок с декоратором, но только теперь ему во wraper нужно передать какое-то значение, иначе выдаст ошибку.
def my_decor(func):
    def wraper(n): # тут нужно указать аргумент во wraper, иначе выдаст ошибку.
        print('Start')
        func(n) # тут нужно указать аргумент во wraper, иначе выдаст ошибку.
        print('Emd')
    return wraper

@my_decor
def my_func(number): # давайте, пусть наша функция будет получать какое-то число, а возвращать она будет это число
# возведенное в квадрат.
    print(number ** 2)

my_func(10) # Передаем в функцию аргумент (число), которое хотим возвести в квадрат.
# Start
# 100
# Emd


# Мы можем использовать один и тот же декоратор с абсолютно любым кол-вом фукнций. А так же можем декорировать любую
# функцию любым декоратором.
# Могут быть случаи, когда к одной функции вы применяете несколько декораторов - тогда они они будут вызываться в
# обратном порядке, относительно того, как они были вызваны. Например (указаны вымышленые декораторы и функция,
# чисто для прмера, чтоб показать порядок, последовательность применения нескольких декораторов к одной функции:
@decorator1
@decorator2
def f():

# НАписанное выше будет выполняться в следующем порядке:
a = decorator1(decorator2(f))

# В обычной обстановке новички не используют декораторы, но чтобы сделать урок более практическим рассмотрим
# следующее: очень удобно проверять декораторы для тестирования работы скорость какой-то фукнции (т.е. замерить время
# которое было до наала работы функции, затем за сколько времени функция отработала и сколько времени было в конце
# после отработки функции). Для этого нам надо импортироовать такой модуль как time, чтоб замерить время:
import time


# Создаем наш декоратор и передаем ему функцию в качестве аргумента, т.е. ту функцию, которую мы и будем замерять:
def my_decor(func):
    def my_wrap():  # создаю обертку, в которой мы должны замерять время
        start_time = time.time()  # в ней мы должны создать какую-то переменную start_time, которое будет временем на
        # начало  выполнения нашей функции и оно будет равно текущему времени (обращаясь к модулю time, там возьмем
        # текущее время: time.time()
        func()  # Затем вызовем нашу функцию, она у нас отработает
        print(time.time() - start_time)  # и тут мы узнаем за сколько времени отработала функция, путем вычитания
        # актуального времени на конец функции минус время по состоянию на начало отработки функции)
    return my_wrap


# А теперь создадим саму функции, которую мы будем замерать на скорость при помощи декоратора. Например, фуккция,
# которая создаст список квадратов четных элементов от 0 до 100.000 и возьме в него только четные числа:

@my_decor  # нам нужно декорировать нашу функцию уже известным способом (собачка и имя декора-фукнции)
def sp():
    spisok = [i ** 2 for i in range(100000) if i % 2 == 0]
    print(spisok)


# Теперь, просто вызываем нашу функцию sp:
sp()
# ... 9996400324, 9996800256, 9997200196, 9997600144, 9998000100, 9998400064, 9998800036, 9999200016] - кусок
# последней строки возведения в квадрат до 100.000.
# 0.018929481506347656 - время выполнения в секундах



# Подытожим, для чего нужны декораторы. Декораторы нужны для того, чтоб не повторять какие-то блоки кода и чтобы
# дополнять функциональность уже написанных функций.